generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Role {
  id        Int      @id @default(autoincrement())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  users     User[]
}

model User {
  id                  Int                @id @default(autoincrement())
  email               String             @unique
  password            String
  name                String
  profilePicture      String?            @db.Text
  sign                String?            @db.Text
  roleId              Int
  status              String             @default("PENDING")
  verificationToken   String?            @db.Text
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  balanceChanges      BalanceAuditLog[]  @relation("BalanceChanges")
  documents           Document[]         @relation("UploadedDocuments")
  notes               Note[]             @relation("UserNotes")
  signatureRequests   SignatureRequest[] @relation("SignerRequests")
  assignedTasks       Task[]             @relation("AssignedTasks")
  ownedTaskLists      TaskList[]         @relation("OwnedTaskLists")
  taskListMemberships TaskListMember[]   @relation("TaskListMemberships")
  transactions        Transaction[]      @relation("CreatedTransactions")
  createdForms        Form[]             @relation("CreatedForms")
  formResponses       FormResponse[]     @relation("UserFormResponses")
  archives            Archive[]          @relation("UploadedArchives")
  archiveFolders      ArchiveFolder[]    @relation("CreatedArchiveFolders")
  archiveShares       ArchiveShare[]     @relation("CreatedArchiveShares")
  role                Role               @relation(fields: [roleId], references: [id], onDelete: Cascade)
  createdAssets      Asset[]             @relation("AssetCreator")
  borrowedLoans      Loan[]              @relation("Borrower")
  approvedLoans      Loan[]              @relation("LoanApprover")
  assetLogs         AssetLog[]          @relation("LogCreator")

  @@index([roleId], map: "User_roleId_fkey")
}

model Form {
  id          String         @id @default(uuid())
  title       String
  description String?        @db.Text
  slug        String         @unique
  schema      Json
  isActive    Boolean        @default(true)
  settings    Json?
  createdById Int
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  createdBy   User           @relation("CreatedForms", fields: [createdById], references: [id], onDelete: Cascade)
  responses   FormResponse[]

  @@index([createdById], map: "Form_createdById_fkey")
}

model FormResponse {
  id          String   @id @default(uuid())
  formId      String
  userId      Int?
  guestName   String?
  data        Json
  ipAddress   String?
  userAgent   String?  @db.Text
  submittedAt DateTime @default(now())
  form        Form     @relation(fields: [formId], references: [id], onDelete: Cascade)
  user        User?    @relation("UserFormResponses", fields: [userId], references: [id], onDelete: SetNull)

  @@index([formId], map: "FormResponse_formId_fkey")
  @@index([userId], map: "FormResponse_userId_fkey")
}

model Transaction {
  id          Int      @id @default(autoincrement())
  type        String
  amount      Float
  description String   @db.Text
  category    String
  proofImage  String?  @db.Text
  date        DateTime
  createdById Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   User     @relation("CreatedTransactions", fields: [createdById], references: [id], onDelete: Cascade)

  @@index([createdById], map: "Transaction_createdById_fkey")
}

model Document {
  id          Int                @id @default(autoincrement())
  title       String
  filePath    String             @db.Text
  checksum    String             @unique
  uploaderId  Int
  deletedAt   DateTime?
  deletedById Int?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  uploader    User               @relation("UploadedDocuments", fields: [uploaderId], references: [id], onDelete: Cascade)
  hash        DocumentHash?
  requests    SignatureRequest[]

  @@index([uploaderId], map: "Document_uploaderId_fkey")
}

model DocumentHash {
  id            Int      @id @default(autoincrement())
  documentId    Int      @unique
  originalHash  String
  signedHash    String?
  signatureData String?  @db.Text
  algorithm     String   @default("SHA256")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  document      Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
}

model SignatureRequest {
  id         Int       @id @default(autoincrement())
  documentId Int
  signerId   Int
  status     String    @default("PENDING")
  isSigned   Boolean   @default(false)
  x          Float
  y          Float
  page       Int
  type       String    @default("signature")
  text       String?   @db.Text
  width      Float?
  height     Float?
  fontSize   Float?
  signedAt   DateTime?
  rejectedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  document   Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  signer     User      @relation("SignerRequests", fields: [signerId], references: [id], onDelete: Cascade)

  @@index([documentId], map: "SignatureRequest_documentId_fkey")
  @@index([signerId], map: "SignatureRequest_signerId_fkey")
}

model FinanceSettings {
  id             Int      @id @default(autoincrement())
  initialBalance Float    @default(0)
  balanceDate    DateTime @default(now())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model BalanceAuditLog {
  id          Int      @id @default(autoincrement())
  oldBalance  Float
  newBalance  Float
  oldDate     DateTime
  newDate     DateTime
  changedById Int
  changedAt   DateTime @default(now())
  changedBy   User     @relation("BalanceChanges", fields: [changedById], references: [id], onDelete: Cascade)

  @@index([changedById], map: "BalanceAuditLog_changedById_fkey")
}

model TaskList {
  id          Int              @id @default(autoincrement())
  name        String           @db.VarChar(255)
  description String?          @db.Text
  ownerId     Int
  createdAt   DateTime?        @default(now()) @db.DateTime(0)
  updatedAt   DateTime?        @default(now()) @updatedAt @db.DateTime(0)
  tasks       Task[]
  owner       User             @relation("OwnedTaskLists", fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Restrict, map: "TaskList_ibfk_1")
  members     TaskListMember[]

  @@index([ownerId], map: "ownerId")
}

model TaskListMember {
  id         Int       @id @default(autoincrement())
  taskListId Int
  userId     Int
  permission String?   @default("EDITOR") @db.VarChar(50)
  invitedAt  DateTime? @default(now()) @db.DateTime(0)
  taskList   TaskList  @relation(fields: [taskListId], references: [id], onDelete: Cascade, onUpdate: Restrict, map: "TaskListMember_ibfk_1")
  user       User      @relation("TaskListMemberships", fields: [userId], references: [id], onDelete: Cascade, onUpdate: Restrict, map: "TaskListMember_ibfk_2")

  @@unique([taskListId, userId], map: "unique_member")
  @@index([userId], map: "userId")
}

model Task {
  id          Int       @id @default(autoincrement())
  title       String
  description String?   @db.Text
  status      String    @default("PENDING")
  order       Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  category    String?
  completedAt DateTime?
  dueDate     DateTime?
  priority    String    @default("MEDIUM")
  taskListId  Int
  assigneeId  Int?
  taskList    TaskList  @relation(fields: [taskListId], references: [id], onDelete: Cascade, onUpdate: Restrict, map: "Task_ibfk_1")
  assignee    User?     @relation("AssignedTasks", fields: [assigneeId], references: [id], onDelete: Restrict, onUpdate: Restrict, map: "Task_ibfk_2")

  @@index([assigneeId], map: "assigneeId")
  @@index([taskListId], map: "taskListId")
}

model Note {
  id        Int      @id @default(autoincrement())
  userId    Int
  title     String   @default("Untitled")
  content   String?  @db.LongText
  color     String   @default("default")
  isPinned  Boolean  @default(false)
  coverImage String? @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation("UserNotes", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "Note_userId_fkey")
}

model ArchiveFolder {
  id          Int             @id @default(autoincrement())
  name        String          @db.VarChar(255)
  description String?         @db.Text
  parentId    Int?
  createdById Int
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  parent      ArchiveFolder?  @relation("FolderChildren", fields: [parentId], references: [id], onDelete: Cascade)
  children    ArchiveFolder[] @relation("FolderChildren")
  createdBy   User            @relation("CreatedArchiveFolders", fields: [createdById], references: [id], onDelete: Cascade)
  archives    Archive[]

  @@index([parentId], map: "ArchiveFolder_parentId_fkey")
  @@index([createdById], map: "ArchiveFolder_createdById_fkey")
}

model Archive {
  id          Int            @id @default(autoincrement())
  filename    String         @db.VarChar(255)
  originalName String        @db.VarChar(255)
  filePath    String         @db.Text
  fileSize    Int
  mimeType    String         @db.VarChar(255)
  category    String         @default("Lainnya") @db.VarChar(100)
  folderId    Int?
  uploadedById Int
  version     Int            @default(1)
  parentVersionId Int?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  folder      ArchiveFolder? @relation(fields: [folderId], references: [id], onDelete: SetNull)
  uploadedBy  User           @relation("UploadedArchives", fields: [uploadedById], references: [id], onDelete: Cascade)
  parentVersion Archive?     @relation("ArchiveVersions", fields: [parentVersionId], references: [id], onDelete: SetNull)
  childVersions Archive[]    @relation("ArchiveVersions")
  shares      ArchiveShare[]

  @@index([folderId], map: "Archive_folderId_fkey")
  @@index([uploadedById], map: "Archive_uploadedById_fkey")
  @@index([parentVersionId], map: "Archive_parentVersionId_fkey")
}

model ArchiveShare {
  id          Int      @id @default(autoincrement())
  archiveId   Int
  shareToken  String   @unique @db.VarChar(255)
  permission  String   @default("VIEW") @db.VarChar(50)
  expiresAt   DateTime?
  createdById Int
  createdAt   DateTime @default(now())
  archive     Archive  @relation(fields: [archiveId], references: [id], onDelete: Cascade)
  createdBy   User     @relation("CreatedArchiveShares", fields: [createdById], references: [id], onDelete: Cascade)

  @@index([archiveId], map: "ArchiveShare_archiveId_fkey")
  @@index([createdById], map: "ArchiveShare_createdById_fkey")
}

model AssetCategory {
  id        Int      @id @default(autoincrement())
  name      String   @unique
  code      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  assets    Asset[]
}

model Asset {
  id            Int      @id @default(autoincrement())
  name          String
  assetCode     String   @unique
  barcode       String   @unique
  qrCode        String?
  categoryId    Int
  status        String   @default("AVAILABLE")
  brand         String?
  model         String?
  serialNumber  String?
  purchaseDate   DateTime?
  purchasePrice Float?
  location      String?
  description   String?   @db.Text
  imageUrl      String?   @db.Text
  createdById   Int
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  category      AssetCategory @relation(fields: [categoryId], references: [id])
  createdBy     User         @relation("AssetCreator", fields: [createdById], references: [id])
  loans         Loan[]
  logs          AssetLog[]

  @@index([categoryId])
  @@index([createdById])
  @@index([status])
}

model Loan {
  id            Int      @id @default(autoincrement())
  assetId       Int
  borrowerId    Int
  status        String   @default("PENDING")
  requestDate   DateTime @default(now())
  approvedDate  DateTime?
  borrowedDate  DateTime?
  dueDate       DateTime?
  returnedDate   DateTime?
  approvedById  Int?
  notes         String?  @db.Text
  returnCondition String?
  returnNotes   String?  @db.Text
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  asset         Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  borrower      User      @relation("Borrower", fields: [borrowerId], references: [id])
  approvedBy    User?     @relation("LoanApprover", fields: [approvedById], references: [id])
  logs          AssetLog[]

  @@index([assetId])
  @@index([borrowerId])
  @@index([status])
  @@index([dueDate])
}

model AssetLog {
  id        Int      @id @default(autoincrement())
  assetId   Int
  loanId    Int?
  action    String
  actionDate DateTime @default(now())
  userId    Int
  notes     String?  @db.Text
  createdAt DateTime @default(now())
  asset     Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  loan      Loan?    @relation(fields: [loanId], references: [id], onDelete: SetNull)
  user      User      @relation("LogCreator", fields: [userId], references: [id])

  @@index([assetId])
  @@index([actionDate])
}
